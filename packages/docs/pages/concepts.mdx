# Concepts

## `baseUrl`

If your app is hosted on Vercel, Bunnygram will try to guess your `baseUrl`. Otherwise if your app is deployed to another host, or you are testing on `localhost`, you should set the `baseUrl` manually in the config.

Note that most adapters (except for the basic adapter) won't work when testing on `localhost`, since these services have no way of talking to your `localhost`. To overcome this limitation, you can use `ngrok`, `tailscale` etc. which can help expose your computer to the internet.

## Payload validation with Zod

You can add runtime type safety by providing a validator to the config, like this:

```ts
// tasks/send-email.ts

import { z } from "zod";
import { makeConfig } from "bunnygram";

const JobPayloadSchema = z.object({
  emailAddress: z.string(),
  emailBody: z.string(),
});

interface JobResponse {
  status: boolean;
}

export const sendEmail = makeConfig<
  z.infer<typeof JobPayloadSchema>,
  JobResponse
>({
  route: "/api/send-email",
  validator: JobPayloadSchema,
});
```

The validator will be run inside both `send()` and `onReceive()` to make sure that the received data conforms to the expected type.

## How it works

Conceptually, Bunnygram is straighforward. It instantiates a Next.js API handler and another function to invoke it. It abstracts away some of the boilerplate regarding parsing request bodies, providing type safety and so on.

The flow of data is as follows. The `send()` function (introduced previously) sends a `POST` request with your payload to your adapter's backend e.g. QStash. That backend will then forward that payload by sending another `POST` request to the API handler. The handler will receive the data in `onReceive()` and run your job with it.
